---
title: p4 程序的完整理解，从编译到测试
date: 2019-02-27 13:12:02
tags: p4
---

从源文件到一层层的API


<!--more-->

[TOC]

# 开源社区的开发环境和SDE 的对比

简单做了对比，还不是很清楚behavioral model这种虚拟交换机的API和bf私有的API 的区别。

现在可以确定的结论是： F9500 内的SDE 包含的正确完整的从p4 src（我们自定义） -》 pd-api（根据我们的自定义自动生成） -》 switchAPI（写死的） -》 SAI（写死的） 的整个栈

## behavioral model

参考：https://github.com/p4lang/behavioral-model

一个模拟的软交换机，它会加载`p4c-bm` 生成的json 文件，来虚拟出一个交换机。

对应我们的tofino 硬件

## p4c-bm 

参考：https://github.com/p4lang/p4c-bm

编译器，编译出的目标文件运行在bm 虚拟出来的交换机

从p4-suite 来看和bf 的 p4c-tofino ，这些p4c 的变体，其前端都相同，只是后端会根据不同的target 生成不同产物

## 在tofino上

使用p4c-tofino  

	p4c-tofino switch.p4

# barefoot SDE 中

步骤大致如下：

## configure

按照官方的标准，我们在build 的目录下开始工作

![image](https://ws3.sinaimg.cn/large/005JrW9Kgy1g0l6qxi8ehj30qt09jwgs.jpg)

通过上面的命令，你指定好自己的程序的位置，enable_thrift 可以设定为yes， 这使得我们可以生成thrift 的服务端API，通过 thrift RPC访问这个API。

通过`configure` 我们得到：

![image](https://wx4.sinaimg.cn/large/005JrW9Kgy1g0l6viohgsj30qr09ht9v.jpg)

## MAKE:接下来就可以make 了

可以看到期间会检查我们p4 程序的源码的正确性，弹出一些warning

![image](https://ws3.sinaimg.cn/large/005JrW9Kgy1g0l6wbbhosj30qm0imwhn.jpg)

通过make install 我们可以将编译好的lib.so 放到合适的位置，这些具体的位置，体现在一个conf 文件中。在最后我们使用`bf-switchd`运行一个p4 程序时，会用到这个文件。

## 备注：我们的程序只有pd相关的API

从上述的make 说起，这个make 其实仅仅能在build 文件夹内，编译我们的p4 程序，得到的是数据层面的可执行文件，以及开放给上层的PD-API

而这些上层，如果想要添加，那么需要自己定义。

官方给出的switchAPI 就是针对 switch.p4 手动实现的一个层。

还是可以通过下图来理解其位置，以及各个组件的关系

```
    +-----+   +-----+   +-----+   +-----+
    |App a|   |App j|   |App n|   |App z|
    |     |...|     |...|     |...|     |
    +-----+   +-----+   +-----+   +-----+
       |         |         |         |
       |         |    +----|         |
+------------+   |    |
| Switchlink |   |    |
|            |<-----------------------------+
+------------------+  |                     |
|     SAI          |  |                     |
|                  |  |                     |
+-----------------------+                   |
|      Switch API       |                   |
|                       |                   |
+-----------------------+---------+         |
|      Resource Mgmt. API         |         |
| (auto-gen. from switch.p4)      |         | Netlink events
+---------------------------------+         |
|        Soft Switch              |         |
|  (compiled from switch.p4)      |         |
+---------------------------------+         |
                                            |
                                            |
+----------------------------------------------------------------+
|                             Kernel                             |
|                                                                |
+----------------------------------------------------------------+
```

## 还是从前面提到的conf来说

从下方的记录，你可以知道：

 当你使用： `./run_switchd.sh –p myprog` 时，加载的就是这些conf 文件


![image](https://ws1.sinaimg.cn/large/005JrW9Kgy1g0l79mvh5rj30w90pjwi9.jpg)

然后我们可以看 [SDE编译流程分析](https://anonymity12.github.io/2019/02/26/SDE%20%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/) 第二节查看具体的这些库的产生的install



# API 跟踪

当我们知道了p4 被编译后，通过各种makefile 的参数，所有的lib.so 以及thrift server都已经ready，终于，我们以及运行了。

那么，在我们可以打开一个bf-shell 的时候，bfshell 可以进入到多个子命令界面

比如

![image](https://ws1.sinaimg.cn/large/005JrW9Kgy1g0l7ukcv2aj30f504ea9x.jpg)

![image](https://ws4.sinaimg.cn/large/005JrW9Kgy1g0l7ukgh94j30fe07h749.jpg)

这些bfshell 中动态变化的子界面，是和我们运行时程序相关的，我们的配置conf 文件中，会指定让bfshell 去加载什么模块，而这些模块要么可以访问pd-api （默认必选），要么可以访问switchAPI（当你指定加载了这个模块），有的甚至可以向上更一层，访问SAI的API（当你指定加载这个模块）

我们要知道，他们三者是类似栈一样，不断堆叠，向下依赖。

我们如果要重新定义（增量修改原来的switch.p4) 那么就要了解这个堆叠是如何发生的。

## 以一个vlan的变动为示例

我们从ptf 中发现有这样的一个测试用例

![image](https://ws2.sinaimg.cn/large/005JrW9Kgy1g0l80zy4imj30fg0ecwev.jpg)

在 `class L2TrunkRemoveReaddVlanTest(ApiAdapter):` 中

![image](https://wx2.sinaimg.cn/large/005JrW9Kgy1g0l8abnlsdj30nr0d0aaj.jpg)

我们然后进入其父类`ApiAdapter`中，找到这个方法


![image](https://ws4.sinaimg.cn/large/005JrW9Kgy1g0l8d3jsbnj30np092jro.jpg)

可以发现：调用了switchAPI 的`switch_api_vlan_member_add(device, vlan, member)`

那现在如果我们的sourceInsight没有包含switchAPI 是看不到上述函数的，于是我们开启bf 官方出的switchAPI工程（注：GitHub上的开源项目似乎相比比较精简，缺少很多东西）

![image](https://wx3.sinaimg.cn/large/005JrW9Kgy1g0l8kx4u18j30pg0cjt9f.jpg)

上面的c++ 代码就是RPC 的服务端了，那接下来 ，进入对应的c文件，可以看到服务端的逻辑，按照API 栈的堆叠，如何从switchAPI 落回pd-api

来自： 

![image](https://ws2.sinaimg.cn/large/005JrW9Kgy1g0l8qmoz2yj308g00wjr5.jpg)

看到

![image](https://wx3.sinaimg.cn/large/005JrW9Kgy1g0l8nhjndgj30ov04g0sr.jpg)

调用：

```C
switch_status_t switch_api_vlan_member_add_internal(
    const switch_device_t device,
    const switch_handle_t vlan_handle,
    const switch_handle_t intf_handle,
    switch_handle_t *member_handle) {
  switch_vlan_info_t *vlan_info = NULL;
  switch_bd_info_t *bd_info = NULL;
  switch_interface_info_t *intf_info = NULL;
  switch_bd_member_t *bd_member = NULL;
  switch_mcast_member_t mcast_member;
  switch_vlan_t outer_vlan = 0;
  switch_vlan_t inner_vlan = 0;
  switch_uint64_t flags = 0;
  switch_vlan_t native_vlan_id = 0;
  switch_status_t status = SWITCH_STATUS_SUCCESS;

  SWITCH_LOG_ENTER();

//此处省略 几百行

// tt 主要调用了这个
  status = switch_pv_member_add(device,
                                vlan_info->bd_handle,
                                intf_handle,
                                outer_vlan,
                                inner_vlan,
                                flags,
                                member_handle);
 
//此处省略几十行

cleanup:
  return status;
}
```

switch_pv_member_add（）调用了pd 相关的函数，接着进去看看

如下`switch_pd_port_vlan_to_bd_mapping_table_entry_add`

```
  if (flags & SWITCH_BD_MEMBER_PD_PV_UNTAGGED_BD_ENTRY) {
    if (!(SWITCH_HW_FLAG_ISSET(bd_member,
                               SWITCH_BD_MEMBER_PD_PV_UNTAGGED_BD_ENTRY))) {
                               	//tt: 这里调用了pd相关的
      status = switch_pd_port_vlan_to_bd_mapping_table_entry_add(
          device,
          intf_info->port_lag_index,
          FALSE,
          0x0,
          FALSE,
          0x0,
          bd_info->bd_entry,
          &bd_member->pv_bd_entry[SWITCH_BD_MEMBER_PV_UNTAGGED_ENTRY]);
      if (status != SWITCH_STATUS_SUCCESS) {
        SWITCH_LOG_ERROR(
            "pv bd member add failed on device %d "
            "bd handle %lx intf handle %lx: "
            "pv mapping table untagged entry add failed(%s)\n",
            device,
            bd_handle,
            intf_handle,
            switch_error_to_string(status));
        goto cleanup;
      }
      SWITCH_HW_FLAG_SET(bd_member, SWITCH_BD_MEMBER_PD_PV_UNTAGGED_BD_ENTRY);
    }
  }

```

`switch_pd_port_vlan_to_bd_mapping_table_entry_add`调用了：

和官方`switch.p4`实现相关的pd-api

（注：这里官方将switch.p4 的pd-api 的函数命名使用pd-dc开头，是因为switch.p4 的问世，刚开始是通过一篇和数据中心【Data Center】相关的论文实现的）


![image](https://wx2.sinaimg.cn/large/005JrW9Kgy1g0l95s3fgxj30o10jrdgp.jpg)

![image](https://wx1.sinaimg.cn/large/005JrW9Kgy1g0l98z3de1j30kk0huaav.jpg)

- [ ] 0227 找到pd api 在F9500中的位置（待测试见机器复原）




